<?xml version="1.0" encoding="utf-8"?><article lang="en">

<articleinfo>

<releaseinfo>Colorer-take5 be5 library HRC Reference. January 2010</releaseinfo>
<title>HRC Language Reference</title>

<pubdate>12 January 2010</pubdate>

<revhistory>
<revision>
  <revnumber>take5.be5 (rev2)</revnumber>
  <date>12 January 2010</date>
  <revremark>(Available as
    <ulink url="http://colorer.sf.net/hrc-ref/">HTML</ulink>,
    <ulink url="http://colorer.sf.net/hrc-ref/hrc-ref.pdf">PDF</ulink>,
    <ulink url="http://colorer.sf.net/hrc-ref/hrc-ref.zip">DocBook</ulink>)
  </revremark>
</revision>
<revision>
  <revnumber>take5.be5</revnumber>
  <date>26 April 2007</date>
</revision>
<revision>
  <revnumber>take5.beta4</revnumber>
  <date>28 April 2005</date>
</revision>
<revision>
  <revnumber>take5.beta4(draft)</revnumber>
  <date>19 February 2005</date>
</revision>
<revision>
  <revnumber>take5.beta3</revnumber>
  <date>30 January 2004</date>
</revision>
<revision>
  <revnumber>take5.beta2</revnumber>
  <date>12 September 2003</date>
</revision>
<revision>
  <revnumber>take5.beta1</revnumber>
  <date>30 March 2003</date>
</revision>
<revision>
  <revnumber>take5.alpha3</revnumber>
  <date>1 March 2003</date>
</revision>
<revision>
  <revnumber>take5.alpha2</revnumber>
  <date>30 January 2003</date>
</revision>
</revhistory>
<author>
  <firstname>Igor</firstname><surname>Russkih</surname>
  <affiliation>
    <address>
      <email>irusskih at gmail.com</email>
    </address>
  </affiliation>
</author>
<author>
  <firstname>Anatoly</firstname><surname>Techtonik</surname>
  <affiliation>
    <address>
      <email>techtonik at gmail.com</email>
    </address>
  </affiliation>
</author>


<copyright>
<year>2003</year><year>2004</year><year>2005</year><year>2006</year><year>2007</year><year>2010</year>
<holder>Igor Russkih (Cail Lomecb)</holder>
</copyright>

<abstract><title>Abstract</title>
<para>This reference describes <acronym role="Highlighting Resource Codes">HRC</acronym>
language, used in Colorer-take5 Library to define and represent
syntax and lexical structure of various programming languages.
These syntax definitions are used by library to parse and colorize
text in editors and other software.
</para>
</abstract>
</articleinfo>


<section id="introduction">
<title>Introduction</title>

<para>
<emphasis role="strong">HRC</emphasis> is a script language which describes text parsing process to produce syntax
highlighting. It is <emphasis role="strong">XML-based</emphasis> language with its own XML vocabulary and structure.
HRC is designed to make the process of describing structures of programming languages
most flexible and efficient.
</para>
<para>
Looking back to early 1999, HRC had simple XML-like structure describing several
common language constructions. Since then it evolved into very powerful way of
describing complex relations between different languages and syntax contexts.
HRC is a full-fledged "XML application" and that means HRC definitions can be
automatically generated from XML descriptions in other languages and converted
to other formats through XSLT templates or other means.
</para>
<para>
HRC uses <emphasis role="strong">Regular Expressions</emphasis> to achieve flexible recognition
of text elements, lexemes and tokens. Still Regular Expressions (<emphasis role="strong">RE</emphasis>) are able
to recognise only a limited set of syntax constructions when
it is often necessary to describe more complex structures. Therefore HRC uses special
construct named <emphasis role="strong">"scheme"</emphasis> to define behaviour of
more powerful recursive set of languages (context free). Such schemes in combination
with RE make HRC strong declarative language.
</para>
</section>



<section id="basics">
<title>Basics</title>

<section id="basics.parsing">
<title>Syntax processing overview</title>
<para>
When Colorer starts it reads available HRC files to know what syntax highlight
rules are available and to which files they apply to. HRC file usually
contains rules to colorize specific content type. Each of these rules is called
"scheme" and is defined by XML <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.scheme">&lt;scheme&gt;</link> element. Content types are
defined with XML <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link> element with "name" attribute
(such as <emphasis>&lt;type name="python"&gt;</emphasis>). Schemes for this
content type are placed inside of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link>. HRC syntax allows several
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link> elements in HRC file, but usually only one is included.
When colorer knows which type to apply to the given content it starts
processing with <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.scheme">&lt;scheme&gt;</link> element that that has the same name
as enclosed type (i.e. <emphasis>&lt;scheme name="python"&gt;</emphasis> will be the
"main() function" for the python <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link> above).
</para>
<para>
Matching <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link> to content is made using information from
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.prototype">&lt;prototype&gt;</link> element that contains filename masks and content
tests (see below). HRC is very flexible in layout, and for convenience all
prototypes are extracted into main <emphasis>proto.hrc</emphasis> file.
</para>
</section>

<section id="basics.hrc.syntax">
<title>HRC syntax components</title>
<para>
HRC describes and stores syntax rules for numerous languages. All language definitions
are divided into two parts:
<itemizedlist>
  <listitem><para>
<emphasis role="strong">informal part</emphasis> includes different non-syntax specific
properties of a language: name, short description, common file extensions and autodetection
rules. Informal part is also called <emphasis role="strong">language prototype</emphasis>.
  </para></listitem>
  <listitem><para>
<emphasis role="strong">formal part</emphasis> contains actual definition of target language
rules in terms of syntax and semantics. It is referenced as <emphasis role="strong">language type</emphasis>.
  </para></listitem>
</itemizedlist>
Prototypes are used to detect correct language type that should be applied to a file,
they define some application-dependent properties and other useful information about
languages. Because prototypes are separated from real language definitions, full type
loading occurs only when language is correctly matched or requested by user. This
guarantees fast library bootstrap. Prototype definitions grouped into one file allow
users to get a quick overview of the languages supported by the library.
</para>

<formalpara><title>Structure</title><para>
Each HRC file contains either several language prototypes or
one language type. XML content starts with root <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.hrc">&lt;hrc&gt;</link>
element, which contains all other HRC definitions.

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.hrc"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_hrc"><literal>&lt;hrc&gt;</literal></link></para><para role="xsdoc">Root of the HRC file XML structure.</para><para role="xsdochead">Attribute:
   <literal>version</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NMTOKEN"><literal>xs:NMTOKEN</literal></ulink></para><para role="xsdoc">Specifies version of HRC language. For example, 'take5' for Colorer-take5.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.annotation"><literal>annotation</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.prototype"><literal>prototype</literal></link></para><para role="xsdoc">Defines prototype of single target programming language.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.package"><literal>package</literal></link></para><para role="xsdoc">Defines prototype of the defined file type, but use this type as an internal hidden package structure.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.type"><literal>type</literal></link></para><para role="xsdoc">Language container, used to store all parser specific information.</para></informalexample>

</para>


<para>
Every bit of HRC is either XML element or attribute.
You can find formal definition of the HRC XML syntax in <xref linkend="hrcxsd"/>.
For instance, all HRC files start with the syntax similar to following:



<example id="example.hrc.file"><title>Common HRC file</title>
<programlisting>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hrc PUBLIC "-//Cail Lomecb//DTD Colorer HRC take5//EN"
  "http://colorer.sf.net/2003/hrc.dtd"&gt;
&lt;hrc version="take5" xmlns="http://colorer.sf.net/2003/hrc"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://colorer.sf.net/2003/hrc
                         http://colorer.sf.net/2003/hrc.xsd"&gt;
  &lt;annotation&gt;
   &lt;documentation&gt;
   your documentation...
   &lt;/documentation&gt;
  &lt;/annotation&gt;

  your definitions...

&lt;/hrc&gt;

</programlisting></example>

</para>

<para>
Each element in HRC can be documented with <emphasis>XML Schema</emphasis>-like
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.annotation">&lt;annotation&gt;</link>:
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.annotation"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_annotation"><literal>&lt;annotation&gt;</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <literal>appinfo</literal></para><para role="xsdoc">Formal annotation part, used for tools processing.</para><para role="xsdochead">Element:
   <literal>documentation</literal></para><para role="xsdoc">Human documentation part.</para><para role="xsdochead">Element:
   <literal>contributors</literal></para><para role="xsdoc">Contribute information part.</para></informalexample>

Annotations can be used anywhere in HRC file to describe and document syntax
elements.

</para>
</formalpara>
</section>


<section id="basics.filetypes"><title>File Types</title>
<para>HRC rules can reuse or import definitions from each other, some
languages (like HTML) may include bits of other languages (i.e. PHP),
so HRC files can depend on each other for correct highlighting. Therefore
HRC files are more like one big database than a bunch of separate
definitions. To link them together several syntax elements are used.
</para>


<section id="basics.filetypes.proto"><title>Prototypes</title>

<para>
Each language is identified by name and short description. This information
is included in language prototype. Names are used to reference languages
in HRC rules. Prototypes are usually contained in top level file
<emphasis role="strong">proto.hrc</emphasis>, but considering flexible
syntax of HRC they could be just everywhere.
</para>

<para>
Prototypes are defined by <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.prototype">&lt;prototype&gt;</link> elements.

<example id="example.hrc.prototype"><title>Prototype definition</title>
<programlisting>
  &lt;prototype name="cpp" group="main" description="C++"&gt;
    &lt;location link="base/cpp.hrc"/&gt;
    &lt;filename&gt;/\.(cpp|cxx|cc|hpp|h)$/i&lt;/filename&gt;
    &lt;firstline&gt;/^\s*(\/\* | \/\/)/xi&lt;/firstline&gt;
    &lt;firstline&gt;/\#include/&lt;/firstline&gt;
    &lt;firstline&gt;/\#define|\#if/&lt;/firstline&gt;
  &lt;/prototype&gt;

</programlisting></example>

The example shows prototype for "C++" language. It contains short
description, information about language group and location of HRC file
with formal part of syntax definition. It also includes RE to identify the
language by filename extension and one or more RE to guess the language
by first few lines (or several hundred bytes - depends on implementation)
of file contents.
</para>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.prototype"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_prototype"><literal>&lt;prototype&gt;</literal></link></para><para role="xsdoc">Defines prototype of single target programming language. This prototype must have name, equals to real type, defined in the linked resource.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">Common internal name of this language type. Must be valid XML non-qualified name.</para><para role="xsdochead">Attribute:
   <literal>description</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">User description, used to represent language in target IDE.</para><para role="xsdochead">Attribute:
   <literal>group</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#Name"><literal>xs:Name</literal></ulink></para><para role="xsdoc">Group of languages, this language belongs to.</para><para role="xsdochead">Attribute:
   <literal>targetNamespace</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#anyURI"><literal>xs:anyURI</literal></ulink></para><para role="xsdoc">Applicable to the XML group of languages. Specifies namespace, this HRC file describing. Allows automatically linking and combining different XML languages in HRC.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.annotation"><literal>annotation</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.location"><literal>location</literal></link></para><para role="xsdoc">Points to the location of a HRC file with this language description.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.filename"><literal>filename</literal></link></para><para role="xsdoc">Defines Regular Expression, used to identify programming language by its file name.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.firstline"><literal>firstline</literal></link></para><para role="xsdoc">Defines Regular Expression, used to identify programming language by its starting content.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.parameters"><literal>parameters</literal></link></para><para role="xsdoc">Custom parameters, used to specify additional properties of this language type.</para></informalexample>

<para>

If language is not specified explicitly library needs to detect it to
start syntax highlighting process. This is the purpose of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.firstline">&lt;firstline&gt;</link> and <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.filename">&lt;filename&gt;</link>
parameters. Each matched instance of one of these parameters adds additional
weight to the language. Default amount of points added can be specified
explicitly with <emphasis>weight</emphasis> attribute of these elements.
When all weights are calculated, the first language with maximum weight is
selected to highlight the file.

</para>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.filename"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_filename"><literal>&lt;filename&gt;</literal></link></para><para role="xsdoc">Defines Regular Expression, used to identify programming language by its file name. This can include file's extension or some more complex dependencies.</para><para role="xsdochead">Attribute:
   <literal>weight</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#decimal"><literal>xs:decimal</literal></ulink>, default:
     <literal>2</literal></para><para role="xsdoc">This attribute defines weight, added to the total language weight, when choosing one from a list of available.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.firstline"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_firstline"><literal>&lt;firstline&gt;</literal></link></para><para role="xsdoc">Defines Regular Expression, used to identify programming language by its starting content. First line can be used, or some small part of text. This entry has less default weight against filename one.</para><para role="xsdochead">Attribute:
   <literal>weight</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#decimal"><literal>xs:decimal</literal></ulink>, default:
     <literal>1</literal></para><para role="xsdoc">This attribute defines weight, added to the total language weight, when choosing one from a list of available.</para></informalexample>

<para>
If any of these two elements is used more than once, each matched
instance adds specified amount to the total weight of a language.
</para>

<para>
Actual language definition can be separated from its prototype and placed
into other file (or resource). In this case <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.location">&lt;location&gt;</link> element
specifies where to find the definition. The file or resource specified
will not be loaded until language matches and is selected for highlightning
process.
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.location"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_location"><literal>&lt;location&gt;</literal></link></para><para role="xsdoc">Points to the location of a HRC file with this language description. Link is a well formed URI address of the requested HRC file. This location can be relative to the current location of the parent type, or absolute (with URI schemas, supported by library). If URI schema is absent, 'file://' is assumed.</para><para role="xsdochead">Attribute:
   <literal>link</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#anyURI"><literal>xs:anyURI</literal></ulink></para></informalexample>
</para>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.parameters"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_parameters"><literal>&lt;parameters&gt;</literal></link></para><para role="xsdoc">Custom parameters, used to specify additional properties of this language type. These can include different language resources (icons, templates and so on). Also these parameters could be referenced from schema declaration, this allows to customize schemes loading process.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <literal>param</literal></para><para role="xsdoc">Single parameter [name,value] pair.</para></informalexample>
</section>


<section id="basics.filetypes.package"><title>Packages</title>
<para>
Some syntax rules are common across various languages and it makes
sense to define them separately and reference from other definitions.
These definitions will not be visible to end users, so they can be
thought of as "internal types". Such internal types are represented
by <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.package">&lt;package&gt;</link> element:

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.package"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_package"><literal>&lt;package&gt;</literal></link></para><para role="xsdoc">Defines prototype of the defined file type, but use this type as an internal hidden package structure.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">Common internal name of this package. Must be valid XML non-qualified name.</para><para role="xsdochead">Attribute:
   <literal>description</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">User description, used to represent package in target IDE.</para><para role="xsdochead">Attribute:
   <literal>targetNamespace</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#anyURI"><literal>xs:anyURI</literal></ulink></para><para role="xsdoc">Applicable to the XML group of languages. Specifies namespace, this HRC file describing. Allows automatically linking and combining different XML languages in HRC.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.annotation"><literal>annotation</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.location"><literal>location</literal></link></para><para role="xsdoc">Points to the location of a HRC file with this language description.</para></informalexample>

This element doesn't contain <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.filename">&lt;filename&gt;</link> or <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.firstline">&lt;firstline&gt;</link>
properties, because it doesn't directly map to any type of file or language. 
In everything else its behaviour is identical to <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.prototype">&lt;prototype&gt;</link>
element. Packages can be found in any HRC file including <emphasis>proto.hrc</emphasis>.
For example:

<example id="example.hrc.package"><title>Package definition</title>
<programlisting>
  &lt;package name="def" group="packages" description="basic definitions"&gt;
    &lt;location link="default.hrc"/&gt;
  &lt;/package&gt;
  &lt;package name="regexp" group="packages" description="Regexp common library"&gt;
    &lt;location link="lib/regexp.hrc"/&gt;
  &lt;/package&gt;

</programlisting></example>
</para>

</section>


<section id="basics.filetypes.type"><title>Types</title>
<para>
Type is a <link linkend="basics">formal definition</link> of a language. It is normally contained in a separate file,
which is referenced by <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.location">&lt;location&gt;</link> element of language prototype. <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link>
element is the starting point for parsing process, which holds syntax specific information.

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.type"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_type"><literal>&lt;type&gt;</literal></link></para><para role="xsdoc">Language container, used to store all parser specific information. These defines are used by parser to analyze and colorize target text data.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">HRC Language type name.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.annotation"><literal>annotation</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.import"><literal>import</literal></link></para><para role="xsdoc">External type import statement.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.region"><literal>region</literal></link></para><para role="xsdoc">Definition of basic syntax region - text range with assigned syntax meaning.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.entity"><literal>entity</literal></link></para><para role="xsdoc">HRC Entity definition.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.scheme"><literal>scheme</literal></link></para><para role="xsdoc">HRC scheme is a basic unit, which represents some fixed set of lexemes, tokens and syntax regions (lexical context).</para></informalexample>

Normally, each type is defined in a separate file, which may optionally
contain corresponding prototype (if there is no prototype definition in
the global repository).

</para>
</section>


</section>

<section id="basics.namespaces"><title>Namespaces</title>
<para>
Each type defines its own name space with its elements. Each element must have
unique identifier (local name) in this namespace, which is used to reference it
from other elements. Within the same type all elements should be unique, but
elements with the same name can belong to different types.
</para>

<para>
An element can be referenced from the other type with its fully
qualified name in form of <emphasis>typename:elementname</emphasis>.
Sometimes there are a lot of inter-type links and use of qualified names
can become a tedious task. To make the job easier HRC language has
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.import">&lt;import&gt;</link> statement. It 'imports' all element names from
other type into the current. There can be as many import statements as
needed. Unqualified names are resolved in order of their definition.



<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.import"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_import"><literal>&lt;import&gt;</literal></link></para><para role="xsdoc">External type import statement. This statement imports all definitions from the specified type into the current one, so you can use them without explicit type qualifier.</para><para role="xsdochead">Attribute:
   <literal>type</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para></informalexample>

For instance, you can write
<programlisting>
  &lt;import type='def'/&gt;
</programlisting>
to import all definitions from the 'def' type. Note, that if several
imported types have some identical local names, they are resolved in
order of import statements, i.e. the first one is used.



</para>
</section>

</section>



<section id="schemesyntax"><title>Scheme syntax</title>

<para>
Scheme is a generic structure of the HRC language to define syntax of programming
languages. Every scheme contains various syntax elements, matched or not matched
as text analysis
goes on. For example, a scheme for "C++" language contains different keywords,
strings, numbers, comments etc. The scheme is defined by <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.scheme">&lt;scheme&gt;</link>
element.
</para>

<para>
Scheme alone is not very useful for analysis. It is much more
convenient to think about text of a language to be highlighted in terms of
<emphasis role="strong">regions</emphasis>. When schema matches a piece of text it
can assign various parts of this text to different regions.
Each <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.region">&lt;region&gt;</link> defines some meaningful part of the syntax.
This part or region always has a name and sometimes a reference to its parent
region (if any). When parsed, source text is described as a set of these regions
with specified positions and lengths.


</para>

<para>
Next stage of the text processing associates each region with some handler.
A handler, for example, can assign color and font style information to
each of the regions or apply other operations to these structures.
</para>

<para>
Each region is defined using a <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.region">&lt;region&gt;</link> element:
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.region"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_region"><literal>&lt;region&gt;</literal></link></para><para role="xsdoc">Definition of basic syntax region - text range with assigned syntax meaning. Later, these regions can be mapped into required color information and displayed on screen.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">HRC Region name.</para><para role="xsdochead">Attribute:
   <literal>parent</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">Region's parent reference. If region has parent, its properties can be inherited from this one. Also region inheritance creates tree structure of HRC Regions.</para><para role="xsdochead">Attribute:
   <literal>description</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Optional description, used to represent region's purpose and to show it to user in convenient and friendly way.</para></informalexample>
</para>

<para>
During parsing process each element in a scheme not only creates one or more
syntax <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.region">&lt;region&gt;</link>s used to highlight parsed text. Resulting information
also contains a recursive scheme tree showing overall text structure.
</para>

<para>
Each type may define as many schemes as needed provided that all their names are
unique within the type. Scheme is defined using <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.scheme">&lt;scheme&gt;</link> element:

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.scheme"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_scheme"><literal>&lt;scheme&gt;</literal></link></para><para role="xsdoc">HRC scheme is a basic unit, which represents some fixed set of lexemes, tokens and syntax regions (lexical context). Each time at any position in the text only one schema is active. Its content is applied to the current text position. When the text parsing process starts, the scheme is used whose name equals the name of the corresponding type (the base scheme of the type).</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">HRC Scheme name. Unique in this type scope.</para><para role="xsdochead">Attribute:
   <literal>if</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">Load and use this scheme's content only if parameter, to which references this attribute is truth. In other case this scheme is used as an empty one.</para><para role="xsdochead">Attribute:
   <literal>unless</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">Load and use this scheme's content only if parameter, to which references this attribute is not truth. In other case this scheme is used as an empty one.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.annotation"><literal>annotation</literal></link></para><para role="xsdoc">Defines formal documentation for the HRC language elements.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.regexp"><literal>regexp</literal></link></para><para role="xsdoc">Regular Expression token.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.block"><literal>block</literal></link></para><para role="xsdoc">Context switch operator.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.keywords"><literal>keywords</literal></link></para><para role="xsdoc">List of tokens with equal properties.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.inherit"><literal>inherit</literal></link></para><para role="xsdoc">Scheme inheritance construction.</para></informalexample>

Every type is required to have one scheme called <emphasis role="strong">"base scheme"</emphasis>
which is used as an entry point for parsing process of the type. Base scheme is
named after its type, i.e. local name of the scheme is equal to the name
of the type. Only internal types defined with <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.package">&lt;package&gt;</link> element can
ignore this requirement because they are never used at the top level.

<example id="example.hrc.type"><title>Sample type definition</title>
<programlisting>
  &lt;type name="somelang"&gt;
    &lt;region name="Keyword" description="This language's keyword"/&gt;
    &lt;scheme name="somelang"&gt;
      &lt;keywords region="Keyword"&gt;
        &lt;word name='word1'/&gt;&lt;word name='word2'/&gt;
        &lt;word name='otherkeyword'/&gt;
      &lt;/keywords&gt;
      &lt;regexp match="/other(keyword)?/i" region="Keyword"/&gt;
    &lt;/scheme&gt;
  &lt;/type&gt;
</programlisting></example>

</para>
<para>
Scheme element may contain <emphasis>if/unless</emphasis> attributes to customize
parsing process according to contents of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.parameters">&lt;parameters&gt;</link> definitions
in the type of the schema. Parameters can be flexibly changed at runtime by the
means of Colorer API. This allows customizing load process and suggesting
various language profiles to be chosen by user.


</para>

<para>
The following sections describe different types of syntax elements,
available in the HRC language.
</para>

<section id="schemesyntax.keywords"><title>Keyword lists</title>
<para>
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.keywords">&lt;keywords&gt;</link> is the most simple HRC element used to quickly define
words with similar properties and highlight them in a text.
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.keywords"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_keywords"><literal>&lt;keywords&gt;</literal></link></para><para role="xsdoc">List of tokens with equal properties. Keywords, symbols and so on... These lists are used to make processing of many tokens faster, when it isn't required to use RE to define syntax tokens.</para><para role="xsdochead">Attribute:
   <literal>ignorecase</literal>, default:
     <literal>yes</literal></para><para role="xsdoc">Match this list of tokens with case sensitive or no.</para><para role="xsdochead">Attribute:
   <literal>region</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">Region, assigned to this list of tokens. Each token can define its custom region.</para><para role="xsdochead">Attribute:
   <literal>priority</literal>, type:
     <link linkend="xsid_hrc_priority"><literal>priority</literal></link>, default:
     <literal>low</literal></para><para role="xsdoc">Priority of any token can be normal and low.</para><para role="xsdochead">Attribute:
   <literal>worddiv</literal>, type:
     <link linkend="xsid_hrc_REworddiv"><literal>REworddiv</literal></link></para><para role="xsdoc">Class of characters, used to search words edges.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.word"><literal>word</literal></link></para><para role="xsdoc">Keyword tokens - use specified word edges.</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.symb"><literal>symb</literal></link></para><para role="xsdoc">Symbol tokens - ignores specified word edges.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.word"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_word"><literal>&lt;word&gt;</literal></link></para><para role="xsdoc">Keyword tokens - use specified word edges.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdochead">Attribute:
   <literal>region</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">A pair of type name and valid XML name.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.symb"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_symb"><literal>&lt;symb&gt;</literal></link></para><para role="xsdoc">Symbol tokens - ignores specified word edges.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdochead">Attribute:
   <literal>region</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">A pair of type name and valid XML name.</para></informalexample>
</para>
<para>
Each element in the list may assign its own region or use region of its parent
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.keywords">&lt;keywords&gt;</link> element. Symbols never check surrounding characters,
while words match only if surrounded by not-word symbols. These word delimiters can be
redefined with <emphasis>worddiv</emphasis> attribute of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.keywords">&lt;keywords&gt;</link>.
</para>
</section>

<section id="schemesyntax.re"><title>Regular Expressions</title>
<para>
Regular expression rules is a powerful and flexible way to define custom
syntax structures. Each RE token can be used to create several different syntax
regions (up to 16). Keep in mind, however, that the scope of every RE in Colorer
is limited to one line (the only exception is <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.firstline">&lt;firstline&gt;</link> element
matched against several lines to detect file type).
</para>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.regexp"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_regexp"><literal>&lt;regexp&gt;</literal></link></para><para role="xsdoc">Regular Expression token.</para><para role="xsdochead">Attribute:
   <literal>region</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">A pair of type name and valid XML name.</para><para role="xsdochead">Attribute:
   <literal>priority</literal>, type:
     <link linkend="xsid_hrc_priority"><literal>priority</literal></link>, default:
     <literal>normal</literal></para><para role="xsdoc">Priority of any token can be normal and low.</para><para role="xsdochead">Attribute:
   <literal>match</literal>, type:
     <link linkend="xsid_hrc_REstring"><literal>REstring</literal></link></para><para role="xsdoc">RE syntax</para></informalexample>

<para>
Actual RE is contained within <emphasis role="strong">match</emphasis> attribute of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link>
element. Detailed explanation of Colorer-take5 regular expressions is in <xref linkend="hrcre"/>.
Each <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> can have up to 16 optional attributes named 
<emphasis role="strong">region0, region1, ... regionf</emphasis> where hexadecimal digit
corresponds to the part of RE surrounded by round brackets counted from left to right. 
<emphasis role="strong">region0</emphasis> means whole sequence matched by RE (this can be changed with
<emphasis role="strong">\m</emphasis> and <emphasis role="strong">\M</emphasis> RE metasymbols).
The value of each attribute is a name of the syntax region used to highlight text. 

Regular Expression can also contain named brackets what explicitly specify corresponding
syntax region in the form of <emphasis role="strong">(?{name} ... )</emphasis>.
</para>

<para>
Each RE definition can include references to any predefined sequence of RE code.
Such references are called <emphasis role="strong">entities</emphasis>. Entities are
defined in <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.type">&lt;type&gt;</link> element and have their own qualified namespace.
To include entity's value into RE, special syntax of <emphasis role="strong">%entityname;</emphasis> is used.
</para>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.entity"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_entity"><literal>&lt;entity&gt;</literal></link></para><para role="xsdoc">HRC Entity definition. Entities are some form of macro-definitions, they lately can be used in regular expressions syntax to make them simpler. Each entity consists of Entity name and Entity content, which would be substituted into regular expression, when parser finds entity reference. Each entity can be referenced with %entityname; syntax.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NCName"><literal>xs:NCName</literal></ulink></para><para role="xsdoc">HRC Entity name.</para><para role="xsdochead">Attribute:
   <literal>value</literal>, type:
     <link linkend="xsid_hrc_REentity"><literal>REentity</literal></link></para><para role="xsdoc">HRC Entity value, used to substitute entity in RE string.</para></informalexample>

<para>
Each RE has a priority attribute (by default its value is <emphasis>normal</emphasis>).
Priority is mainly used to detect errors when closing matching region. When everything within
the region is already matched and parser needs to close the block, it applies rule to
match closing sequence. If match fails then rule with <emphasis>low</emphasis>
priority within the block is tested. This is explained in <xref linkend="schemesyntax.boundaries"/>
</para>

</section>

<section id="schemesyntax.contextswitch"><title>Block context switch</title>
<para>
Regular expressions are very powerful, but some complex language constructions
still can not be described with their help. For example, syntax elements that
allow recursion, i.e. braces inside braces that can be wrapped into each other
multiple number of times. There is also a limitation of Colorer's RE parser
that it can not see beyond a single line of text. 
</para>
<para>
To define more complex syntax structures and context-free grammar constructions
HRC has a special element named <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link>.

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.block"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_block"><literal>&lt;block&gt;</literal></link></para><para role="xsdoc">Context switch operator. Used to switch currently used context into the specified one. Context is switched, if RE pattern, placed in 'start' attribute, is matches. Switched context is closed, when parser finds match of the 'end' RE.</para><para role="xsdochead">Attribute:
   <literal>start</literal>, type:
     <link linkend="xsid_hrc_REstring"><literal>REstring</literal></link></para><para role="xsdoc">Regular Expression</para><para role="xsdochead">Attribute:
   <literal>end</literal>, type:
     <link linkend="xsid_hrc_REstring"><literal>REstring</literal></link></para><para role="xsdoc">Regular Expression</para><para role="xsdochead">Attribute:
   <literal>scheme</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">A pair of type name and valid XML name.</para><para role="xsdochead">Attribute:
   <literal>priority</literal>, type:
     <link linkend="xsid_hrc_priority"><literal>priority</literal></link>, default:
     <literal>normal</literal></para><para role="xsdoc">Priority of any token can be normal and low.</para><para role="xsdochead">Attribute:
   <literal>content-priority</literal>, type:
     <link linkend="xsid_hrc_priority"><literal>priority</literal></link>, default:
     <literal>normal</literal></para><para role="xsdoc">Priority of any token can be normal and low.</para><para role="xsdochead">Attribute:
   <literal>inner-region</literal>, default:
     <literal>no</literal></para><para role="xsdoc">If set to "yes" then the region of referenced scheme does not include text matched by start/end attributes. I.e. all the block's regions are located outside of the scheme region. By default ("no" value) scheme region wraps start/end tokens of the block and defines background for their own regions.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <literal>start</literal>, type:
      <link linkend="ref.hrc.blockInner"><literal>blockInner</literal></link></para><para role="xsdoc">Alternative style of RE definition.</para><para role="xsdochead">Element:
   <literal>end</literal>, type:
      <link linkend="ref.hrc.blockInner"><literal>blockInner</literal></link></para><para role="xsdoc">Alternative style of RE definition.</para></informalexample>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.blockInner"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_blockInner"><literal>&lt;blockInner&gt;</literal></link></para><para role="xsdoc">Alternative style of RE definition. Could be used, when RE is very complex and it is easier to use character (or CDATA) sections to define it.</para><para role="xsdochead">Attribute:
   <literal>match</literal>, type:
     <link linkend="xsid_hrc_REstring"><literal>REstring</literal></link></para><para role="xsdoc">RE syntax</para></informalexample>

Each block has <emphasis>&lt;start&gt;</emphasis> and <emphasis>&lt;end&gt;</emphasis>
tags, each with the RE syntax already described.
Everything contained within these two marks will be highlighted
as a syntax of some other <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.scheme">&lt;scheme&gt;</link>, also pointed by this
element's attribute. It is also possible to paint the portions of these matched
tags. Much like <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> element - <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> can contain
up to 32 region attributes - <emphasis role="strong">region, region00, region01, ... region1f</emphasis>.
<emphasis>region0x</emphasis> corresponds to round brackets of <emphasis>&lt;start&gt;</emphasis> tag,
<emphasis>region1x</emphasis> is for <emphasis>&lt;end&gt;</emphasis> tag brackets and <emphasis>region</emphasis> attribute
contains a name of region to paint the whole block. So it is not necessary to define scheme for
assigning region to the whole block, but since scheme is a required attribute there is a stub 
empty scheme you can use named <emphasis role="strong">def:empty</emphasis>
</para>
<para>
Using <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> element you can switch context
between different highlighting schemes. This way it is possible to define
a great number of different syntax combinations.
</para>

</section>

<section id="schemesyntax.boundaries"><title>Scheme boundaries and priority</title>
<para>
Both regular expressions and block'ed scheme switches work in the same scheme context,
and tested against text in the order they defined in HRC.
If current text is matched by several rules, the first rule wins. 
After successful RE match parse position is increased by
the length of that RE. By default the width is calculated from the first matched symbol till the last
inclusive. However it is possible to adjust these boundaries and shift parse position.
This is done with special <emphasis role="strong">\m</emphasis>
(redefines RE start) and <emphasis role="strong">\M</emphasis> (redefines RE end) metasymbols.
It becomes possible to define overlapped elements, where parsing of the following element starts
somewhere in the middle of the previous.
</para>
<section id="priority"><title>priority</title>
<para>
Sometimes a conflict occurs between the rule that closes block
(i.e. <emphasis>&lt;end&gt;</emphasis> tag of the <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> element)
and a matching rule inside this block. By default the rule inside block always
wins. But sometimes rule that closes block should take precedence. For this
purpose HRC defines <emphasis role="strong">priority</emphasis>
attribute for <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> and <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> elements.
Its default value is <emphasis>"normal"</emphasis>, but if it is changed to
<emphasis>"low"</emphasis> then Colorer does not take into account this element
when resolving conflicts upon exit from inner scheme. I.e. in case of conflict
if inner element has lowered priority then <emphasis>&lt;end&gt;</emphasis> tag
of the outer <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> element is used. 
In case of nested <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> tag, <emphasis>priority</emphasis> attribute
affects only conflicts with its <emphasis>&lt;start&gt;</emphasis> tag.
<emphasis>&lt;end&gt;</emphasis> tag of nested block will always take precedence
over the similar <emphasis>&lt;end&gt;</emphasis> tag of enclosing block.
</para>
<para>
For regular expressions with lowered priority EOL metacharacter
<emphasis>$</emphasis> in case of conflict matches the end of parent block area.
This allows to use low <emphasis>priority</emphasis> to highlight syntax errors.

</para>
</section>
<section id="content-priority"><title>content-priority</title>
<para>
Sometimes it is required to dynamically define priority of a child scheme within a block.

With <emphasis>priority</emphasis> attribute it is impossible to change element's priority
depending on a context from where the element is called, because the element will
always have the priority specified. Instead <emphasis>content-priority</emphasis> attribute of a
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> element is used to change priority for all elements of referenced
scheme.
</para>
<para>
When changed into <emphasis>low</emphasis> it causes all the elements of that scheme
to change their priority to <emphasis>low</emphasis> no matter what is the value of their
particular <emphasis>priority</emphasis> attribute. 
</para>
</section>

<section id="inner-region"><title>inner-region</title>
<para>
When defining scheme context switch it is possible to set a default region
for content of called scheme through <emphasis>region</emphasis> attribute of
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> element. The region will be used as a "background" for
all other regions defined in that scheme.
It is possible to manage boundaries of this region.
Normally the whole scheme's content together with contents of <emphasis>&lt;start&gt;</emphasis>
and <emphasis>&lt;end&gt;</emphasis> tokens is included in this default region.
Region starts where <emphasis>&lt;start&gt;</emphasis> token starts, and
ends where <emphasis>&lt;end&gt;</emphasis> token ends.
</para>
<para>
Sometimes it is desirable to change this behaviour and handle <emphasis>&lt;start&gt;</emphasis>
and <emphasis>&lt;end&gt;</emphasis> tokens (and all the regions they may define) outside of
default region of the called scheme. This could be achieved by setting <emphasis>inner-region</emphasis>
attribute to <emphasis>"yes"</emphasis> value.
When set it tells parser to exclude start/end tokens from default region of called scheme
by changing default region boundaries to begin at
the end of <emphasis>&lt;start&gt;</emphasis> token and finish just before <emphasis>&lt;end&gt;</emphasis>
token area.
</para>
<para>
Inner region feature could be used to implement special wrapped areas and in general
can affect special background color treatment.

</para>
</section>

</section>

</section>



<section id="interscheme"><title>Inter-scheme links</title>

<section id="interscheme.inheritance"><title>Inheritance</title>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.inherit"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_inherit"><literal>&lt;inherit&gt;</literal></link></para><para role="xsdoc">Scheme inheritance construction. If one scheme is inherited in another, then the latter scheme takes all the definitions from the former, as it was included directly in place of inherit operator. One scheme can't inherit another, if that scheme is already makes inheritance (even indirect) of the first one.</para><para role="xsdochead">Attribute:
   <literal>scheme</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">Inherited scheme name.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrc.virtual"><literal>virtual</literal></link></para><para role="xsdoc">Inheritance substitution element.</para></informalexample>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrc.virtual"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrc_virtual"><literal>&lt;virtual&gt;</literal></link></para><para role="xsdoc">Inheritance substitution element. While inheriting one scheme in another, it is possible to redefine inner inherited schemes with some others. This can be used to change inherited language behavior.</para><para role="xsdochead">Attribute:
   <literal>scheme</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">Redefined scheme.</para><para role="xsdochead">Attribute:
   <literal>subst-scheme</literal>, type:
     <link linkend="xsid_hrc_QName"><literal>QName</literal></link></para><para role="xsdoc">Scheme to use instead redefined one.</para></informalexample>

<para>
</para>
</section>

<section id="interscheme.substitution"><title>Scheme substitutions</title>
<para/>
</section>
</section>


<section id="coding.std"><title>HRC Language Features and Conventions</title>
<para>
Although HRC itself could be used in an arbitrary way, Colorer-take5
library has a number of coding and naming conventions for consistency
to make maintenance and expansion of HRC library easier. Features are
implemented using special conventions Colorer library knows about and
does extra processing.
</para>

<section id="coding.std.naming"><title>Elements naming</title>
<para>
Colorer names are case sensitive. All regions in Colorer-take5 HRC database are named
with capital letter, each name-part also starts with capital
letter. For instance: <emphasis>StringQuote</emphasis>. Any separate type or
package is named in lower case and shortened if possible. So, the full name
of a region is written as <emphasis>def:StringQuote</emphasis>.
</para>

<para>
Scheme names are context dependent and could be used with words in either case.
Dash or Dot delimiter makes them more readable:
<emphasis>&lt;scheme name="Comment.content"&gt;</emphasis> for instance.
</para>

<para>
All HRC files are named in lower-case with
possible Dash or Dot delimiters. External XML entities should be used
to split complex HRC files in parts that simplifies generation of automatically
derived HRC schemes. Entity files carry double <emphasis>ent.hrc</emphasis>
extensions to distinguish them from ordinary HRC schemes.
</para>
</section>

<section id="coding.std.spec"><title>Default package feature</title>
<para>
Colorer-take5 defines a basic set of common syntax regions through
special package named <emphasis role="strong">def</emphasis>. Default package simplifies
support of HRC database and separates parse content and its presentation. It is located in
<emphasis>hrc/lib/default.hrc</emphasis>.
The general purpose of this file is to define a basic set of syntax
regions. These regions already have assigned colors via universal
HRD color mappings bundled with Colorer library. All other HRC regions
should be inherited from this set to flexibly define HRD color rules and
unify them across all supported syntaxes and languages.
Any HRC package can explicitly import and use them or define its own
syntax regions, derived from the defaults.
</para>

<section id="coding.std.spec.pairs"><title>Pair construction matching</title>
<para>
In addition to coloring rules, Colorer-take5 library uses some naming conventions to
provide such features as pair matching, error lists and file structure outlines.
Conventions include several special regions. Paired constructions 
are defined using 
<emphasis role="strong">def:PairStart</emphasis> and <emphasis role="strong">def:PairEnd</emphasis>.
Parsing layout for these regions should be properly enwrapped in a valid recursive sequence.
Using this information Colorer-take5 library provides user with
ability to jump over text blocks in target language and highlight them during
editing process.

</para>
</section>

<section id="coding.std.spec.outline"><title>Outliner construction</title>
<para>
Another feature Colorer-take5 library provides is a tree of valuable syntax tokens 
in a text. The tree allows to quickly switch among these tokens in editor.
Tokens may represent programming language's functions, procedures,
or any other logical structures of the text. During parsing process these constructions are collected
into a special outline container, which can present them to user in realtime or by request.
Colorer-take5 editor implements two basic forms of outliner: functions and errors list.
Any HRC scheme may define an element with region equal to or derived from
<emphasis role="strong">def:Outlined</emphasis>. All elements with this region are considered to be
outliner-targeted and are collected during parsing. Outliner may analyse
parse tree structure to generate tree-like text outliners.
Moreover, any language can provide special algorithmic support or logic to implement
parsing for special outlined regions and building valid outline tree.
For instance EclipseColorer editor evaluates a name of each outlined region and searches
an icon with such name. If found, it uses this icon to customize outliner window
items with graphic objects, not only text.
</para>
<para>
Outliner can generally be set up against any region type. It works as a kind of filter,
gathering only required information from parser. This is a way Errors list works,
where regions derived from <emphasis role="strong">def:Error</emphasis> are collected. Every
HRC language uses this region to mark problems it found while parsing text.
</para>
</section>

</section>


<section id="coding.rec"><title>Coding Recommendations</title>
<para>
HRC database has a long history, during which the format,
syntax and meaning of its compounds were changed to reach more logical and formal structure.

As a consequence there still could be some type definitions, which are
not fully comply with general HRC conventions.
In general these include invalid names of packages and region/schemes.
They won't be supported in their current form and will be reworked
one day to become compliant with other HRC definitions.
</para>
<para>
It may seem a good point to have an <emphasis role="strong">import</emphasis> element in HRC,
which allows to use objects from other package with unqualified names,
but in general this should not be overused to avoid confusion. It is much more convenient
to use fully qualified regions and scheme names to explicitly show additional package
usage/intersections.

</para>
</section>

</section>

<appendix id="hrcre">
<title>Regular Expressions syntax</title>

<section id="hrcre.intro"><title>Introduction</title>
<para>
Colorer library and HRC language rely heavily upon regular expressions (RE).
They allow you to create universal syntax highlighting rules in HRC. The major
difference from other RE engines is that Colorer RE are all limited to one line
to make text processing faster.
</para>

<para>
Regular expression consists of a set of characters.
Some of these are simple, and some are special (metacharacters).
All metacharacters (escapes) are divided into three categories: first - zerolength (words boundaries and so on);
second - class metacharacters (<emphasis>\w</emphasis>, <emphasis>\s</emphasis> <emphasis>.</emphasis>);
and the third - operators.
RE operators can be applied to a single character,
to block, enwrapped in brackets or into other operators.
You can use round brackets to group any sequence of characters.
Regular expressions in HRC Language are much like Perl regexps in their base variant.
There are some differences in extended operators.
</para>
</section>

<section id="hrcre.syntax"><title>Syntax</title>
<para>
All regexps must be in slashes <emphasis>/.../</emphasis>.
After the end slash there can be modifiers:

<itemizedlist>
<listitem><simpara><emphasis>i</emphasis> - ignore symbol case</simpara></listitem>
<listitem><simpara><emphasis>x</emphasis> - ignore direct spaces and crlf (for comfort)</simpara></listitem>
<listitem><simpara><emphasis>s</emphasis> - treat regexp like single line - i.e. make '.' class include \r\n symbols (works only for 
<link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.firstline">&lt;firstline&gt;</link> element) as all other RE can't exceed line boundary</simpara></listitem>
</itemizedlist>
Each symbol in RE is sequentially compared with the target string.
Everything that doesn't look like metacharacter is a simple character.
HRC file is also a valid XML file, therefore quotes in attributes of elements
such as <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> should be escaped with entities 
<emphasis>&amp;quot;</emphasis> or <emphasis>"</emphasis>. Other XML
entities inside <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> are also expanded and should be escaped
when needed. For example, to match <emphasis>&amp;amp;</emphasis> sequence
with your rule - use <emphasis>&amp;amp;amp;</emphasis> construction.
</para>
</section>

<section id="hrcre.meta"><title>Metacharacters</title>

<table id="table.metacharacters"><title>Metacharacters</title><tgroup cols="2"><tbody>
<row><entry><emphasis>^</emphasis></entry><entry>Match the beginning of the line</entry></row>
<row><entry><emphasis>$</emphasis></entry><entry>Match the end of the line</entry></row>
<row><entry><emphasis>.</emphasis></entry><entry>Match any character (except \r\n)</entry></row>
<row><entry><emphasis>[...]</emphasis></entry><entry>Match any character in set</entry></row>
<row><entry><emphasis>[^...]</emphasis></entry><entry>Match any character that is not in set.
          None of RE operators works here, but you some metacharacters and range operator
          are possible:
          <simpara><emphasis>a-z</emphasis> stands for all alphabet chars between a and z,</simpara>
          <simpara><emphasis>[{ASSIGNED}-[{Lu}]-[{Ll}]]</emphasis> - unicode classes reference in RE.</simpara>
          Additional boolean operations:
          <simpara><emphasis>-[]</emphasis> - Class subtraction.</simpara>
          <simpara><emphasis>|[]</emphasis> - Class intersection.</simpara>
          <simpara>
          See <ulink url="http://www.unicode.org/reports/tr18/">Unicode RE TR#18</ulink> for more information.
          </simpara>
          </entry></row>
<row><entry><emphasis>\#</emphasis></entry><entry>The symbol '#' after slash (except a-z and 1-9)</entry></row>
<row><entry><emphasis>\b</emphasis></entry><entry>Word break at this point (immediately before or after any word character)</entry></row>
<row><entry><emphasis>\B</emphasis></entry><entry>No word break at this point</entry></row>
<row><entry><emphasis>\xHH</emphasis>, <emphasis>\x{HHHH}</emphasis></entry><entry><emphasis>HH, HHHH</emphasis> - character code (hex)</entry></row>
<row><entry><emphasis>\n</emphasis></entry><entry>0x10 (lf)</entry></row>                                          
<row><entry><emphasis>\r</emphasis></entry><entry>0x13 (cr)</entry></row>
<row><entry><emphasis>\t</emphasis></entry><entry>0x09 (tab)</entry></row>
<row><entry><emphasis>\s</emphasis></entry><entry>Whitespace character (tab/space/cr/lf)</entry></row>
<row><entry><emphasis>\S</emphasis></entry><entry>Not whitespace</entry></row>
<row><entry><emphasis>\w</emphasis></entry><entry>Word symbol (chars, digits, _)</entry></row>
<row><entry><emphasis>\W</emphasis></entry><entry>Not word symbols</entry></row>
<row><entry><emphasis>\d</emphasis></entry><entry>Digit</entry></row>
<row><entry><emphasis>\D</emphasis></entry><entry>Not Digit</entry></row>
<row><entry><emphasis>\u</emphasis></entry><entry>Uppercase symbol</entry></row>
<row><entry><emphasis>\l</emphasis></entry><entry>Lowercase symbol</entry></row>
</tbody></tgroup></table>
</section>

<section id="hrcre.exmeta"><title>Extended metacharacters</title>
<para>These metacharacters are incompatible with Perl</para>
<table id="table.xmetacharacters"><title>Extended Metacharacters</title><tgroup cols="2"><tbody>
<row><entry><emphasis>\c</emphasis></entry><entry>Means 'not word' before</entry></row>
<row><entry><emphasis>\N</emphasis></entry><entry>Reference from inside of regexp to one of its brackets.
          <emphasis>N</emphasis>  - the number of brackets pair.  This operator  works
          only with non-operator symbols in a bracket.

</entry></row>
</tbody></tgroup></table>

<para>
Next operators are only available in Colorer-take5 regexp parser module,
when it is compiled for Colorer library (means that Colorer regex module can be used separately):
</para>
<table id="table.take5metacharacters"><title>Colorer-take5 Parsing Metacharacters</title><tgroup cols="2"><tbody>
<row><entry><emphasis>~</emphasis></entry><entry>Matches for the start of parent scheme (end of <emphasis>&lt;start&gt;</emphasis> tag).</entry></row>
<row><entry><emphasis>\m</emphasis></entry><entry>Changes start of regexp</entry></row>
<row><entry><emphasis>\M</emphasis></entry><entry>Changes end of regexp</entry></row>
<row><entry><emphasis>\yN \YN \y{name} \Y{name}</emphasis></entry><entry>Link to the external regexp (in <emphasis>&lt;end&gt;</emphasis> token to <emphasis>&lt;start&gt;</emphasis> token param). N - required bracket pair, name - named bracket.</entry></row>
</tbody></tgroup></table>

<para>
For more information about <emphasis>\m \M</emphasis> meaning see
in <xref linkend="schemesyntax.boundaries"/>.
</para>

</section>


<section id="hrcre.ops"><title>Operators</title>
<para>
Operators can't be used without some preceding character sequence.
Each operator must be applied to the appropriate character,
metacharacter, or their combination enclosed in brackets.
</para>

<table id="table.operators"><title>Operators</title><tgroup cols="2"><tbody>
<row><entry><emphasis>( )</emphasis></entry><entry>Group and remember characters for later use.</entry></row>
<row><entry><emphasis>(?{name} )</emphasis></entry><entry>Group and remember characters using named group.</entry></row>
<row><entry><emphasis>(?{} ) or (?: )</emphasis></entry><entry>Group characters, but don't remember (unnamed group).</entry></row>
<row><entry><emphasis>(?{} )</emphasis></entry><entry>Group and remember characters using unnamed uncounted group.</entry></row>
<row><entry><emphasis>|</emphasis></entry><entry>Alternative. Match previous or next pattern.</entry></row>
<row><entry><emphasis>*</emphasis></entry><entry>Match preceding pattern 0 or more times.</entry></row>
<row><entry><emphasis>+</emphasis></entry><entry>Match preceding pattern 1 or more times.</entry></row>
<row><entry><emphasis>?</emphasis></entry><entry>Match preceding pattern 0 or 1 time.</entry></row>
<row><entry><emphasis>{n}</emphasis></entry><entry>Repeat n times.</entry></row>
<row><entry><emphasis>{n,}</emphasis></entry><entry>Repeat n or more times.</entry></row>
<row><entry><emphasis>{n,m}</emphasis></entry><entry>Repeat from n to m times.</entry></row>
</tbody></tgroup></table>

<para>
Question sign <emphasis>?</emphasis> after operator makes it non-greedy.
For example <emphasis>*</emphasis> operator becomes non-greedy if placing <emphasis>*?</emphasis>
Greedy operator tries to eat as many chars in string as possible. Non-greedy takes minimum.
</para>
</section>


<section id="hrcre.exops"><title>Extended operators</title>
<table id="table.xoperators"><title>Extended Operators</title><tgroup cols="2"><tbody>
<row><entry><emphasis>?#N</emphasis></entry><entry>Look-behind. N - symbol number to look behind.</entry></row>
<row><entry><emphasis>?~N</emphasis></entry><entry>Negative look-behind.</entry></row>
<row><entry><emphasis>?=</emphasis></entry><entry>Look-ahead.</entry></row>
<row><entry><emphasis>?!</emphasis></entry><entry>Negative Look-ahead.</entry></row>
</tbody></tgroup></table>
<para>
Note, that two last operators exist in Perl - in form of <emphasis>(?=foobar)</emphasis>.
But colorer uses syntax <emphasis>(foobar)?=</emphasis>
</para>
</section>

<section id="hrcre.examples"><title>Examples</title>
<example id="example.hrc.re"><title>RE examples</title>
<para>

<variablelist>
<varlistentry>
<term><emphasis>/foobar/</emphasis></term>
<listitem><para>will match "foobar", "foobar barfoo"</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/ FOO bar /ix</emphasis></term>
<listitem><para>will match "foobar" "FOOBAR" "foobar and two other foos"</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/(foo)?bar/</emphasis></term>
<listitem><para>will match "foobar", "bar"</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/^foobar$/</emphasis></term>
<listitem><para>will match _only_ with "foobar"</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/([\d\.])+/</emphasis></term>
<listitem><para>will match any number</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/(foo|bar)+/</emphasis></term>
<listitem><para>will match "foofoofoobarfoobar", "bar"</para></listitem>
</varlistentry>

<varlistentry>
<term><emphasis>/f[obar]+r/</emphasis></term>
<listitem><para>will match "foobar", "for", "far"</para></listitem>
</varlistentry>
</variablelist>

</para>
</example>
</section>

</appendix>


<appendix id="catalog.xml">
<title>Format of catalog.xml file</title>
<para>

Catalog for Colorer Library resources is a convenient way to
centralize maintenance and development of all Colorer features.

This catalog is stored in <emphasis>catalog.xml</emphasis> file
and mapped into the ParserFactory class.

Catalog contains information about all installed HRC modules,
error logging configuration and listing of available HRD sets.

</para>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.catalog.catalog"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_catalog_catalog"><literal>&lt;catalog&gt;</literal></link></para><para role="xsdoc">Describes all available Colorer Library resources.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.catalog.hrc-sets"><literal>hrc-sets</literal></link></para><para role="xsdoc">Lists all installed root locations of HRC codes.</para><para role="xsdochead">Element:
   <link linkend="ref.catalog.hrd-sets"><literal>hrd-sets</literal></link></para><para role="xsdoc">Lists all available HRD sets.</para></informalexample>

<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.catalog.hrc-sets"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_catalog_hrc-sets"><literal>&lt;hrc-sets&gt;</literal></link></para><para role="xsdoc">Lists all installed root locations of HRC codes. These locations are loaded when HRC bases are created.</para><para role="xsdochead">Attribute:
   <literal>log-location</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Path to the default library log file. If missed, there is no logging.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.catalog.location"><literal>location</literal></link></para><para role="xsdoc">Single resource location.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.catalog.hrd-sets"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_catalog_hrd-sets"><literal>&lt;hrd-sets&gt;</literal></link></para><para role="xsdoc">Lists all available HRD sets. Each HRD Entry describes single color scheme, used to represent colored text. Note, that one Entry</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <literal>hrd</literal>, type:
      <link linkend="ref.catalog.hrd-entry"><literal>hrd-entry</literal></link></para><para role="xsdoc">Describes one HRD properties set.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.catalog.hrd-entry"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_catalog_hrd-entry"><literal>&lt;hrd-entry&gt;</literal></link></para><para role="xsdoc">Describes one HRD properties set.</para><para role="xsdochead">Attribute:
   <literal>class</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NMTOKEN"><literal>xs:NMTOKEN</literal></ulink></para><para role="xsdoc">HRD class. Currently available 'console', 'rgb' and 'text' classes.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#NMTOKEN"><literal>xs:NMTOKEN</literal></ulink></para><para role="xsdoc">Internal name of this set, used to referring from executable codes.</para><para role="xsdochead">Attribute:
   <literal>description</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">User-friendly description of this HRD set.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.catalog.location"><literal>location</literal></link></para><para role="xsdoc">Single resource location.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.catalog.location"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_catalog_location"><literal>&lt;location&gt;</literal></link></para><para role="xsdoc">Single resource location. Path can be relative to the catalog location, or absolute URI with or without URI schema specification.</para><para role="xsdochead">Attribute:
   <literal>link</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para></informalexample>

<programlisting xmlns:xs="http://www.w3.org/2001/XMLSchema">&lt;<literal role="xs_elem">schema</literal> <literal role="xs_attr">targetNamespace</literal>="<literal role="xs_attrval">http://colorer.sf.net/2003/catalog</literal>" <literal role="xs_attr">elementFormDefault</literal>="<literal role="xs_attrval">qualified</literal>"
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">catalog</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">catalog</literal>"/&gt;

<anchor id="xsid_catalog_catalog"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.catalog.catalog">catalog</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">hrc-sets</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">hrc-sets</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">hrd-sets</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">hrd-sets</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_catalog_hrc-sets"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.catalog.hrc-sets">hrc-sets</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">log-location</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_catalog_hrd-sets"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.catalog.hrd-sets">hrd-sets</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">hrd</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">hrd-entry</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_catalog_hrd-entry"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.catalog.hrd-entry">hrd-entry</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">class</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NMTOKEN</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NMTOKEN</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">description</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_catalog_location"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.catalog.location">location</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">link</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;
&lt;/<literal role="xs_elem">schema</literal>&gt;
</programlisting>

<para>
</para>
</appendix>

<appendix id="hrd">
<title>Format of HRD color schemes</title>
<para>

<acronym role="Highlighting Resource Descriptions">HRD</acronym>
files used to assign some editor-specific properties to each HRC Region.
Usually these include color and style information.
HRD file is a list of entries each describing one HRC Region.

</para>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrd.hrd"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrd_hrd"><literal>&lt;hrd&gt;</literal></link></para><para role="xsdoc">List of assigns between regions and their external properties. These properties commonly include text decoration parameters, such as color, style, font and so on... Global color layering model can be chosen by the target application, depending on its text presentation style, features and requirements. In general, all transparent colors inherit color value from its parent schema fill color. If the current schema is a top-level, default fore- and back-ground colors are used. Default Colors can be stored in HRD, using standard default region 'def:Text', or can be requested by application from the GUI environment. Note that color properties are requested from Region's parent (in HRC structure) if this region is not declared in HRD. However if region was declared but misses some properties, they are requested from underlying schema fill region which is determined in runtime.</para><para role="xsdocdecl">Content:</para><para role="xsdochead">Element:
   <link linkend="ref.hrd.documentation"><literal>documentation</literal></link></para><para role="xsdoc">Human documentation part</para><para role="xsdochead">Element:
   <link linkend="ref.hrd.assign"><literal>assign</literal></link></para><para role="xsdoc">Single entry, describes region's properties.</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrd.documentation"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrd_documentation"><literal>&lt;documentation&gt;</literal></link></para><para role="xsdoc">Human documentation part</para></informalexample>
<anchor xmlns:xs="http://www.w3.org/2001/XMLSchema" id="ref.hrd.assign"/><informalexample xmlns:xs="http://www.w3.org/2001/XMLSchema" role="xsdocwrap"><para role="xsdocdecl">Element:
    <link linkend="xsid_hrd_assign"><literal>&lt;assign&gt;</literal></link></para><para role="xsdoc">Single entry, describes region's properties. If an entry is specified more than one time, then the latest definition is used. This allows several HRD files to be processed to complete color description of target HRC regions.</para><para role="xsdochead">Attribute:
   <literal>name</literal>, type:
     <link linkend="xsid_hrd_region-name"><literal>region-name</literal></link></para><para role="xsdoc">Full qualified region name (a pair [type:name]). Note, that if region has no HRD properties associations, it inherits properties from its parent. If any of its ancestors has no assigned properties, region visualization must be skipped (it becomes fully transparent).</para><para role="xsdochead">Attribute:
   <literal>fore</literal>, type:
     <link linkend="xsid_hrd_color"><literal>color</literal></link></para><para role="xsdoc">Foreground color. If missed, transparent color assumed.</para><para role="xsdochead">Attribute:
   <literal>back</literal>, type:
     <link linkend="xsid_hrd_color"><literal>color</literal></link></para><para role="xsdoc">Background color. If missed, transparent color assumed.</para><para role="xsdochead">Attribute:
   <literal>style</literal>, type:
     <link linkend="xsid_hrd_style"><literal>style</literal></link></para><para role="xsdoc">Style bits (bold, italic, underline).</para><para role="xsdochead">Attribute:
   <literal>stext</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Text prefix mapping (foreground).</para><para role="xsdochead">Attribute:
   <literal>etext</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Text prefix mapping (background).</para><para role="xsdochead">Attribute:
   <literal>sback</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Text Suffix mapping (foreground).</para><para role="xsdochead">Attribute:
   <literal>eback</literal>, type:
     <ulink url="http://www.w3.org/TR/xmlschema-2#string"><literal>xs:string</literal></ulink></para><para role="xsdoc">Text Suffix mapping (background).</para></informalexample>

<para>
It is possible to maintain different HRD files for different languages,
or to compile them into one single HRD file.
The former allows you to distribute recommended settings with each language,
while the latter to unify modification and storage of changed HRD
settings within provided UI.

</para>
<programlisting xmlns:xs="http://www.w3.org/2001/XMLSchema">&lt;<literal role="xs_elem">schema</literal> <literal role="xs_attr">targetNamespace</literal>="<literal role="xs_attrval">http://colorer.sf.net/2003/hrd</literal>" <literal role="xs_attr">elementFormDefault</literal>="<literal role="xs_attrval">qualified</literal>"
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">hrd</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">hrd</literal>"/&gt;

<anchor id="xsid_hrd_hrd"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrd.hrd">hrd</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">documentation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">documentation</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">assign</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">assign</literal>"/&gt;
      &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrd_documentation"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrd.documentation">documentation</link></literal>" <literal role="xs_attr">mixed</literal>="<literal role="xs_attrval">true</literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
      &lt;<literal role="xs_elem">any</literal> <literal role="xs_attr">namespace</literal>="<literal role="xs_attrval">##other</literal>" <literal role="xs_attr">processContents</literal>="<literal role="xs_attrval">skip</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrd_assign"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrd.assign">assign</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">region-name</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">fore</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">color</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">back</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">color</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">style</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">style</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">stext</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">etext</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">sback</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">eback</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrd_region-name"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region-name</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">\i\c*\:\i\c*</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrd_color"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">color</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">#?[\dA-Fa-f]{1,6}</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrd_style"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">style</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">\d</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;
&lt;/<literal role="xs_elem">schema</literal>&gt;
</programlisting>

<para>
</para>
</appendix>

<appendix id="hrcxsd">
<title>XML Schema for HRC Language</title>
<para>
This XML Schema was automatically generated
from the original <emphasis>hrc.xsd</emphasis> source, available at
<ulink url="http://colorer.sf.net/2003/hrc.xsd">http://colorer.sf.net/2003/hrc.xsd</ulink>.
All comments and documentation tags were stripped to achieve more compact format.
To use this schema for other than informational purposes use up-to-date
version available from the link above.
</para>

<programlisting xmlns:xs="http://www.w3.org/2001/XMLSchema">&lt;<literal role="xs_elem">schema</literal> <literal role="xs_attr">targetNamespace</literal>="<literal role="xs_attrval">http://colorer.sf.net/2003/hrc</literal>" <literal role="xs_attr">elementFormDefault</literal>="<literal role="xs_attrval">qualified</literal>"
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

<anchor id="xsid_hrc_REstring"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">whiteSpace</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">collapse</literal>"/&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">/.*/[ix]*</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrc_REworddiv"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">REworddiv</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">whiteSpace</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">collapse</literal>"/&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">\[.*\]|%.*;</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrc_REentity"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">REentity</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">whiteSpace</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">collapse</literal>"/&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">.*</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrc_REstring-or-null"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">REstring-or-null</literal>"&gt;
    &lt;<literal role="xs_elem">union</literal> <literal role="xs_attr">memberTypes</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
      &lt;<literal role="xs_elem">simpleType</literal>&gt;
        &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
          &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval"/>"/&gt;
        &lt;/<literal role="xs_elem">restriction</literal>&gt;
      &lt;/<literal role="xs_elem">simpleType</literal>&gt;
    &lt;/<literal role="xs_elem">union</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrc_QName"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">QName</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:QName</literal>"&gt;
      &lt;<literal role="xs_elem">pattern</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">(\i\c*:)?\i\c*</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

  &lt;<literal role="xs_elem">attributeGroup</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regionX</literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region2</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region3</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region4</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region5</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region6</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region7</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region8</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region9</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regiona</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regionb</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regionc</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regiond</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regione</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regionf</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
  &lt;/<literal role="xs_elem">attributeGroup</literal>&gt;

  &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">hrc</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">hrc</literal>"/&gt;

<anchor id="xsid_hrc_hrc"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.hrc">hrc</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">choice</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">prototype</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">prototype</literal>"/&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">package</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">package</literal>"/&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">type</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">type</literal>"/&gt;
      &lt;/<literal role="xs_elem">choice</literal>&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">version</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NMTOKEN</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_annotation"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.annotation">annotation</link></literal>"&gt;
    &lt;<literal role="xs_elem">choice</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">appinfo</literal>"&gt;
        &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">mixed</literal>="<literal role="xs_attrval">true</literal>"&gt;
          &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
            &lt;<literal role="xs_elem">any</literal> <literal role="xs_attr">namespace</literal>="<literal role="xs_attrval">##other</literal>" <literal role="xs_attr">processContents</literal>="<literal role="xs_attrval">lax</literal>"/&gt;
          &lt;/<literal role="xs_elem">sequence</literal>&gt;
        &lt;/<literal role="xs_elem">complexType</literal>&gt;
      &lt;/<literal role="xs_elem">element</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">documentation</literal>"&gt;
        &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">mixed</literal>="<literal role="xs_attrval">true</literal>"&gt;
          &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
            &lt;<literal role="xs_elem">any</literal> <literal role="xs_attr">namespace</literal>="<literal role="xs_attrval">##other</literal>" <literal role="xs_attr">processContents</literal>="<literal role="xs_attrval">skip</literal>"/&gt;
          &lt;/<literal role="xs_elem">sequence</literal>&gt;
        &lt;/<literal role="xs_elem">complexType</literal>&gt;
      &lt;/<literal role="xs_elem">element</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">contributors</literal>"&gt;
        &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">mixed</literal>="<literal role="xs_attrval">true</literal>"&gt;
          &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
            &lt;<literal role="xs_elem">any</literal> <literal role="xs_attr">namespace</literal>="<literal role="xs_attrval">##other</literal>" <literal role="xs_attr">processContents</literal>="<literal role="xs_attrval">lax</literal>"/&gt;
          &lt;/<literal role="xs_elem">sequence</literal>&gt;
        &lt;/<literal role="xs_elem">complexType</literal>&gt;
      &lt;/<literal role="xs_elem">element</literal>&gt;
    &lt;/<literal role="xs_elem">choice</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_package"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.package">package</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">description</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">targetNamespace</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:anyURI</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_prototype"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.prototype">prototype</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">location</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">filename</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">filename</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">firstline</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">firstline</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">parameters</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">parameters</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">description</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">group</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:Name</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">targetNamespace</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:anyURI</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_location"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.location">location</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">link</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:anyURI</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_filename"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.filename">filename</link></literal>"&gt;
    &lt;<literal role="xs_elem">simpleContent</literal>&gt;
      &lt;<literal role="xs_elem">extension</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
        &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">weight</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:decimal</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">2</literal>"&gt;
        &lt;/<literal role="xs_elem">attribute</literal>&gt;
      &lt;/<literal role="xs_elem">extension</literal>&gt;
    &lt;/<literal role="xs_elem">simpleContent</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_firstline"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.firstline">firstline</link></literal>"&gt;
    &lt;<literal role="xs_elem">simpleContent</literal>&gt;
      &lt;<literal role="xs_elem">extension</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
        &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">weight</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:decimal</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">1</literal>"&gt;
        &lt;/<literal role="xs_elem">attribute</literal>&gt;
      &lt;/<literal role="xs_elem">extension</literal>&gt;
    &lt;/<literal role="xs_elem">simpleContent</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_parameters"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.parameters">parameters</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">param</literal>"&gt;
        &lt;<literal role="xs_elem">complexType</literal>&gt;
          &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
          &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">value</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
          &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">description</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">optional</literal>"/&gt;
        &lt;/<literal role="xs_elem">complexType</literal>&gt;
      &lt;/<literal role="xs_elem">element</literal>&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_type"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.type">type</link></literal>"&gt;
    &lt;<literal role="xs_elem">choice</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">annotation</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">import</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">import</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">region</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">entity</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">entity</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">scheme</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">scheme</literal>"/&gt;
    &lt;/<literal role="xs_elem">choice</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_scheme"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.scheme">scheme</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">annotation</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"/&gt;
      &lt;<literal role="xs_elem">choice</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regexp</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">regexp</literal>"/&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">block</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">block</literal>"/&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">keywords</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">keywords</literal>"/&gt;
        &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">inherit</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">inherit</literal>"/&gt;
      &lt;/<literal role="xs_elem">choice</literal>&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">if</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">optional</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">unless</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">optional</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_import"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.import">import</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">type</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_entity"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.entity">entity</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">value</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">REentity</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_region"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.region">region</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:NCName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">parent</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">description</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_regexp"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.regexp">regexp</link></literal>"&gt;
    &lt;<literal role="xs_elem">complexContent</literal>&gt;
      &lt;<literal role="xs_elem">extension</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">blockInner</literal>"&gt;
        &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
        &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">normal</literal>"/&gt;
      &lt;/<literal role="xs_elem">extension</literal>&gt;
    &lt;/<literal role="xs_elem">complexContent</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_priority"/>  &lt;<literal role="xs_elem">simpleType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">priority</literal>"&gt;
    &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
      &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">low</literal>"/&gt;
      &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">normal</literal>"/&gt;
    &lt;/<literal role="xs_elem">restriction</literal>&gt;
  &lt;/<literal role="xs_elem">simpleType</literal>&gt;

<anchor id="xsid_hrc_block"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.block">block</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>"&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">start</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">blockInner</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">end</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">blockInner</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">start</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">REstring</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">end</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">REstring</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">scheme</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">normal</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">content-priority</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">normal</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">inner-region</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">no</literal>"&gt;
      &lt;<literal role="xs_elem">simpleType</literal>&gt;
        &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
          &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">yes</literal>"/&gt;
          &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">no</literal>"/&gt;
        &lt;/<literal role="xs_elem">restriction</literal>&gt;
      &lt;/<literal role="xs_elem">simpleType</literal>&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attributeGroup</literal> <literal role="xs_attr">ref</literal>="<literal role="xs_attrval">regionXX</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

  &lt;<literal role="xs_elem">attributeGroup</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">regionXX</literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region00</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region01</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region02</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region03</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region04</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region05</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region06</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region07</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region08</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region09</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0a</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0b</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0c</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0d</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0e</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region0f</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region10</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region11</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region12</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region13</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region14</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region15</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region16</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region17</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region18</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region19</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1a</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1b</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1c</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1d</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1e</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region1f</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
  &lt;/<literal role="xs_elem">attributeGroup</literal>&gt;

<anchor id="xsid_hrc_blockInner"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.blockInner">blockInner</link></literal>"&gt;
    &lt;<literal role="xs_elem">simpleContent</literal>&gt;
      &lt;<literal role="xs_elem">extension</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
        &lt;<literal role="xs_elem">attributeGroup</literal> <literal role="xs_attr">ref</literal>="<literal role="xs_attrval">regionX</literal>"/&gt;
        &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">match</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">REstring</literal>"&gt;
        &lt;/<literal role="xs_elem">attribute</literal>&gt;
      &lt;/<literal role="xs_elem">extension</literal>&gt;
    &lt;/<literal role="xs_elem">simpleContent</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_inherit"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.inherit">inherit</link></literal>"&gt;
    &lt;<literal role="xs_elem">sequence</literal>&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">virtual</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">virtual</literal>" <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"/&gt;
    &lt;/<literal role="xs_elem">sequence</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">scheme</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_virtual"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.virtual">virtual</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">scheme</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">subst-scheme</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_keywords"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.keywords">keywords</link></literal>"&gt;
    &lt;<literal role="xs_elem">choice</literal> <literal role="xs_attr">minOccurs</literal>="<literal role="xs_attrval">0</literal>" <literal role="xs_attr">maxOccurs</literal>="<literal role="xs_attrval">unbounded</literal>"&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">word</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">word</literal>"/&gt;
      &lt;<literal role="xs_elem">element</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">symb</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">symb</literal>"/&gt;
    &lt;/<literal role="xs_elem">choice</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">ignorecase</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">yes</literal>"&gt;
      &lt;<literal role="xs_elem">simpleType</literal>&gt;
        &lt;<literal role="xs_elem">restriction</literal> <literal role="xs_attr">base</literal>="<literal role="xs_attrval">xs:string</literal>"&gt;
          &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">yes</literal>"/&gt;
          &lt;<literal role="xs_elem">enumeration</literal> <literal role="xs_attr">value</literal>="<literal role="xs_attrval">no</literal>"/&gt;
        &lt;/<literal role="xs_elem">restriction</literal>&gt;
      &lt;/<literal role="xs_elem">simpleType</literal>&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">priority</literal>" <literal role="xs_attr">default</literal>="<literal role="xs_attrval">low</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">worddiv</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">REworddiv</literal>"&gt;
    &lt;/<literal role="xs_elem">attribute</literal>&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_symb"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.symb">symb</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;

<anchor id="xsid_hrc_word"/>  &lt;<literal role="xs_elem">complexType</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval"><link linkend="ref.hrc.word">word</link></literal>"&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">name</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">xs:string</literal>" <literal role="xs_attr">use</literal>="<literal role="xs_attrval">required</literal>"/&gt;
    &lt;<literal role="xs_elem">attribute</literal> <literal role="xs_attr">name</literal>="<literal role="xs_attrval">region</literal>" <literal role="xs_attr">type</literal>="<literal role="xs_attrval">QName</literal>"/&gt;
  &lt;/<literal role="xs_elem">complexType</literal>&gt;
&lt;/<literal role="xs_elem">schema</literal>&gt;
</programlisting>

</appendix>


<appendix id="history"><title>History of the changes</title>

<itemizedlist><title>take5.be5 (rev.2), 12 January 2010 (Anatoly Techtonik)</title>
<listitem><para>
Add <xref linkend="basics.parsing"/>.
</para></listitem>
<listitem><para>
Reworded <xref linkend="schemesyntax.boundaries"/> and <xref linkend="priority"/>.
</para></listitem>
<listitem><para>
Documented $ behaviour in low-priority blocks.
</para></listitem>
<listitem><para>
Explained XML quoting for <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> attributes.
</para></listitem>
<listitem><para>
Minor spelling fixes.
</para></listitem>
</itemizedlist>

<itemizedlist><title>take5.be5, 26 April 2007 (Anatoly Techtonik)</title>
<listitem><para>
Many parts of the reference were proofreaded, reworded or clarified. There are still many ideas for improvements in comments.
</para></listitem>
<listitem><para>
Edits for <xref linkend="introduction"/> and abstract.
</para></listitem>
<listitem><para>
Core syntax renamed to <xref linkend="basics"/>.
</para></listitem>
<listitem><para>
<xref linkend="basics.namespaces"/> clarifications.
</para></listitem>
<listitem><para>
Rewritten <xref linkend="schemesyntax.keywords"/>, RE descriptions, type explanation.
</para></listitem>
<listitem><para>
Disambiguation about language features and conventions in <xref linkend="coding.std"/>.
</para></listitem>
<listitem><para>
Various DocBook template enhancements (&lt;x:hrc&gt; reference element, ids for examples and tables, renamed entities, visual style fixes etc.)
</para></listitem>
<listitem><para>
Igor remarks.
</para></listitem>
<listitem><para>
Minor fixes.
</para></listitem>
</itemizedlist>

<itemizedlist><title>take5.beta4, 28 April 2005</title>
<listitem><para>
New <xref linkend="inner-region"/> attribute description.
</para></listitem>
<listitem><para>
Minor HRD schema clarifications.
</para></listitem>
</itemizedlist>

<itemizedlist><title>take5.beta4(draft), 19 February 2005</title>
<listitem><para>
Clarification of <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.regexp">&lt;regexp&gt;</link> and <link xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:x="uri:custom:schema-db" linkend="ref.hrc.block">&lt;block&gt;</link> regions usage.
</para></listitem>
<listitem><para>
"Scheme boundaries and priority" explained.
</para></listitem>
<listitem><para>
"HRC Language Coding Conventions" section was added.
</para></listitem>
</itemizedlist>

</appendix>


<bibliography id="bibliography"><title>References</title>
 
 <bibliomixed id="xml-rec">
 <abbrev>XML 1.0</abbrev>Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen, Eve Maler, editors.
 <citetitle><ulink url="http://www.w3.org/TR/REC-xml">Extensible Markup Language (XML) 1.0 Second Edition</ulink></citetitle>.
 W3C (World Wide Web Consortium), 2000.
 </bibliomixed>
 
 <bibliomixed id="xslt-rec">
 <abbrev>XSLT 1.0</abbrev>James Clark, editor.
 <citetitle><ulink url="http://www.w3.org/TR/xslt">XSL Transformations (XSLT) 1.0</ulink></citetitle>.
 W3C (World Wide Web Consortium), 1999.
 </bibliomixed>

 <bibliomixed id="xmlschema-1">
 <abbrev>W3C XML Schema Structures</abbrev>
 Henry S. Thompson, David Beech, Murray Maloney, Noah Mendelsohn, editors.
 <citetitle><ulink url="http://www.w3.org/TR/xmlschema-1/">XML Schema Part 1: Structures</ulink></citetitle>.
  W3C (World Wide Web Consortium), 2001.
 </bibliomixed>

 <bibliomixed id="xmlschema-2">
 <abbrev>W3C XML Schema Datatypes</abbrev>Paul V. Biron, Ashok Malhotra, editors.
 <citetitle><ulink url="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes</ulink></citetitle>.
  W3C (World Wide Web Consortium), 2001.
 </bibliomixed>

</bibliography>

</article>